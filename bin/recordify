#!/usr/bin/env perl

=head1 NAME

    recordify - convert CSV into a one-line-per-column output

=head1 SYNOPSIS

    recordify [options] <filename>

    This script will output a CSV in a one-line-per-column format, or allow
    you to write Perl code to evaluate for each line.

     Options:
       --delimiter      Provide delimiter in the file. A comma is the default.
       --execute        Provide Perl code that operates on %_ where the keys
                        are the keys in the header, which will be evaluated
                        each line. (@_ is also available, awk-style)
       --verbose        Print files separated by spaces instead of newlines.

    One note about this script's behavior: it is not particularly intelligent
    about embedded delimiters in the CSV. It looks only for quoted portions of
    the record and avoids splitting fields that are surrounded entirely by
    double quotes ("). You may need to pre-process the CSV if this is
    insufficient.

=cut


use open ':std', ':encoding(UTF-8)';

use warnings;
use strict;

use Getopt::Long;
use Pod::Usage qw/pod2usage/;

my $delimiter = ',';
my $execute;
my $verbose;
my $no_header_line;

GetOptions(
    'delimiter=s' => \$delimiter,
    'execute=s'   => \$execute,
    'help|?'      => sub { pod2usage() },
    'no-header'   => \$no_header_line,
    'verbose'     => \$verbose,
);

my $record_count = 0;
my @headers;

while(<>){
    next if m{^$};

    s{\x{FEFF}}{};
    s{\s+$}{};  # using this instead of chomp because the file that I wrote
                # this script for had UTF-8 whitespace characters at the EOL

    my @record_fields = get_fields($delimiter, $_);

    if( $record_count++ == 0 and not $no_header_line ) {
        @headers = @record_fields;
        next;
    }

    die "Wrong number of fields!: $_" if @headers and scalar(@record_fields) != scalar(@headers);

    local %_;
    @_{@headers} = @record_fields;
    local @_;
    @_ = @record_fields;

    if( $execute ) {
        eval $execute;
    }
    else {
        print '-' x 3, "\n" unless $record_count < 3;

        foreach my $index (0..$#headers) {
            print "$headers[$index]: $record_fields[$index]\n";
        }
    }
}

print "$record_count records processed.\n" if $verbose;


sub get_fields {
    my($delimiter, $line) = @_;

    my $FAKE_FIELD = '#!FIELDFIELDFIELD!#';

    my @replacements;
    while( $line =~ s{("[^"]*"(?!"))}{$FAKE_FIELD} ){
        push @replacements, $1;
    }

    my @fields = split /$delimiter/, $line;

    foreach my $field (@fields) {
        if ($field eq $FAKE_FIELD) {
            $field = shift @replacements;
        }
        $field =~ s/^"|"$//g;
    }

    return @fields;
}
