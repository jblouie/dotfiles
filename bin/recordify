#!/usr/bin/env perl

=head1 NAME

    recordify - convert CSV into a one-line-per-column output

=head1 SYNOPSIS

    recordify [options] <filename>

    This script will output a CSV in a one-line-per-column format, or allow
    you to write Perl code to evaluate for each line.

    It will look at whether the first line's fields have any lower- or
    uppercase letters; if it does not, it will assume that it is not a
    header line.

     Options:
       --column            Give a number or field name, print only this column.
       --delimiter         Provide delimiter in the file. A comma is the default.
       --execute           Provide Perl code that operates on %_ where the keys
                           are the keys in the header, which will be evaluated
                           each line. (@_ is also available, awk-style)
       --keep-headers      Print the header line out before any output. This is
                           useful if you are just filtering the CSV somehow.
       --no-headers        Force the first line to be treated as a data line
                           instead of a header line.
       --order             Instead of printing by record, just sort the file by
                           the field specified. Automatically turns on --keep.
       --sum               Sum a particular column, the column name should be given
                           as an argument to this option.
       --template          Process the filename given as the template using a simple
                           handlebar-style template. The template will be rendered
                           once per record.
       --verbose           Print files separated by spaces instead of newlines.

    One note about this script's behavior: it is not particularly intelligent
    about embedded delimiters in the CSV. It looks only for quoted portions of
    the record and avoids splitting fields that are surrounded entirely by
    double quotes ("). You may need to pre-process the CSV if this is
    insufficient.

=cut


use open ':std', ':encoding(UTF-8)';

use warnings;
use strict;

use Getopt::Long;
use Pod::Usage qw/pod2usage/;

my $column_to_print;
my $delimiter = ',';
my $execute;
my $keep_header_line;
my $no_header_line;
my $order_field;
my $sum_field;
my $template;
my $verbose;

GetOptions(
    'column-to-print=s' => \$column_to_print,
    'delimiter=s'       => \$delimiter,
    'execute=s'         => \$execute,
    'help|?'            => sub { pod2usage() },
    'keep-headers'      => \$keep_header_line,
    'no-headers'        => \$no_header_line,
    'order=s'           => \$order_field,
    'sum=s'             => \$sum_field,
    'template=s'        => \$template,
    'verbose'           => \$verbose,
);

$keep_header_line = 1 if $order_field;
my $sum if $sum_field;

if (1 < scalar(grep {defined} ($column_to_print, $order_field, $execute, $template))) {
    die 'Incompatible command-line switches';
}

if ($column_to_print and $column_to_print =~ m{^\d+$}) {
    $column_to_print = "field$column_to_print";
}

if ($order_field and $order_field =~ m{^\d+$}) {
    $order_field = "field$order_field";
}

my $record_count = 0;
my @headers;
my $field_count;
my %ordered_data;
my $template_content;

if( $template ) {
    local $/;
    undef $/;
    open my $fh, '<', $template or die "Couldn't open $template $!";
    $template_content = <$fh>;
    close $fh;
}

LINE:
while(<>){
    next if m{^$};

    s{\x{FEFF}}{};
    s{\s+$}{};  # using this instead of chomp because the file that I wrote
                # this script for had UTF-8 whitespace characters at the EOL

    my @record_fields = get_fields($delimiter, $_);

    unless( @headers ){
        $field_count = scalar(@record_fields);

        if( not $no_header_line and
            $field_count == scalar(grep /[a-zA-Z]/, @record_fields) ) {

            @headers = @record_fields;

            if ($column_to_print and $keep_header_line) {
                print $column_to_print, "\n";
            }
            elsif ($keep_header_line) {
                print $_, "\n";
            }

            next LINE;
        }
        else {
            @headers = map { "field$_" } 1..$field_count;
        }

    }

    if( $order_field and !grep {$order_field eq $_} @headers ){
        die "Order field '$order_field' not found in headers!";
    }

    if ($column_to_print and !grep {$column_to_print eq $_} @headers) {
        die "Column to print '$column_to_print' not found in headers!";
    }

    $record_count++;
    local %_;
    local @_;

    if( @headers ) {
        die "Wrong number of fields!: $_" if scalar(@record_fields) != scalar(@headers);
        @_{@headers} = @record_fields;
    }

    @_ = @record_fields;

    if ($column_to_print) {
        print $_{$column_to_print}, "\n";
    }
    elsif( $sum_field ){
        $sum += $_{$sum_field};
    }
    elsif( $order_field ) {
        push @{$ordered_data{$_{$order_field}}}, $_;
    }
    elsif( $template ) {
        no strict 'refs';
        print '-' x 3, "\n" unless $record_count < 2;
        my $template = $template_content;
        $template =~ s/\{\{(.*?)\}\}/$_{$1}/g;
        $template =~ s/(?<!\n)\z/\n/;
        print $template;
    }
    elsif( $execute ) {
        eval $execute;
    }
    else {
        print '-' x 3, "\n" unless $record_count < 2;

        foreach my $index (0..$#headers) {
            print "$headers[$index]: $record_fields[$index]\n";
        }
    }
}

if( $sum_field ){
    print "Total: $sum\n";
}
elsif( $order_field ){
    foreach my $key (sort %ordered_data){
        foreach my $value (@{$ordered_data{$key}}){
            print $value, "\n";
        }
    }
}

print "$record_count records processed.\n" if $verbose;


sub get_fields {
    my($delimiter, $line) = @_;

    my $FAKE_FIELD = '#!FIELDFIELDFIELD!#';

    my @replacements;
    while( $line =~ s{("(?!").*"(?!"))}{$FAKE_FIELD} ){
        push @replacements, $1;
    }

    my @fields = split /$delimiter/, $line;

    foreach my $field (@fields) {
        if ($field eq $FAKE_FIELD) {
            $field = shift @replacements;
        }
        $field =~ s/^"|"$//g;
    }

    return @fields;
}
